/**
 * Multi-Language RAG Processing
 * ============================
 *
 * Enhanced RAG system with multi-language support for natural conversation
 * in English, Hindi, and Nepali with proper context management.
 */

import Groq from 'groq-sdk'
import { parseLanguageDetectionResponse, safeJsonParse } from './json-utils'
import { conversationToneManager, type ToneContext } from './conversation-tone-manager'
import {
  findConversationTemplate,
  getTemplateResponse,
  getBasicResponse,
} from './natural-language-templates'
import type { VectorResult } from './llm-enhanced-rag'

// Initialize Groq client
const groq = new Groq({
  apiKey: process.env.GROQ_API_KEY || '',
})

export interface LanguageContext {
  detectedLanguage: string
  confidence: number
  translatedQuery?: string
  culturalContext: string[]
  preferredResponseLanguage: string
  needsTranslation?: boolean
}

export interface MultiLanguageRAGResult {
  response: string
  originalLanguage: string
  responseLanguage: string
  translationUsed: boolean
  searchLanguage: string
  metadata: {
    languageDetection: LanguageContext
    ragPattern: string
    searchResults: number
    crossLanguageSearch: boolean
    templateUsed?: string
  }
}

/**
 * Language Detection and Context Analysis
 */
export async function detectLanguageContext(
  message: string,
  deepgramHint?: string,
): Promise<LanguageContext> {
  try {
    // Quick rule-based detection for common patterns
    const messageLower = message.toLowerCase()

    console.log(`üîç Detecting language for: "${message}"`)
    if (deepgramHint) {
      console.log(`üéôÔ∏è Deepgram detected: ${deepgramHint}`)
    }

    // MULTI-LANGUAGE DETECTION - Support for 20+ languages
    // Keywords that are distinctive to each language
    const languagePatterns = {
      hi: {
        name: 'Hindi',
        flag: 'üáÆüá≥',
        keywords: [
          // Romanized
          'kya',
          'kaam',
          'karte',
          'aap',
          'tum',
          'hai',
          'ho',
          'kaise',
          'kahan',
          'kaun',
          'batao',
          'mujhe',
          'mera',
          'tumhara',
          'kab',
          'kyun',
          // Devanagari (for Deepgram transcripts)
          '‡§ï‡•ç‡§Ø‡§æ',
          '‡§ï‡§æ‡§Æ',
          '‡§ï‡§∞‡§§‡•á',
          '‡§Ü‡§™',
          '‡§§‡•Å‡§Æ',
          '‡§π‡•à',
          '‡§π‡•ã',
          '‡§ï‡•à‡§∏‡•á',
          '‡§ï‡§π‡§æ‡§Ç',
          '‡§ï‡•å‡§®',
          '‡§¨‡§§‡§æ‡§ì',
          '‡§Æ‡•Å‡§ù‡•á',
          '‡§Æ‡•á‡§∞‡§æ',
          '‡§§‡•Å‡§Æ‡•ç‡§π‡§æ‡§∞‡§æ',
          '‡§ï‡§¨',
          '‡§ï‡•ç‡§Ø‡•ã‡§Ç',
          '‡§ï‡§∞',
          '‡§∞‡§π‡•á',
          '‡§ñ‡§æ‡§®‡§æ',
          '‡§ñ‡§æ',
          '‡§≤‡§ø‡§Ø‡§æ',
          '‡§Ö‡§ö‡•ç‡§õ‡§æ',
          '‡§§‡•Å‡§Æ‡§®‡•á',
        ],
      },
      ne: {
        name: 'Nepali',
        flag: 'üá≥üáµ',
        keywords: [
          // Common greetings
          'namaste',
          'namaskar',
          'dhanyabad',
          'dhanyabƒÅd',
          // Question words
          'kun',
          'ke',
          'kasto',
          'kahƒÅ',
          'kaha',
          'kahile',
          'kati',
          'kina',
          'kasari',
          'kasle',
          'kasko',
          // Pronouns
          'ma',
          'malai',
          'mero',
          'timro',
          'tapai',
          'tapƒÅƒ´',
          'timi',
          'u',
          'usko',
          'hamilai',
          'hami',
          // Verbs (common)
          'cha',
          'chha',
          '‡§õ',
          'huncha',
          '‡§π‡•Å‡§®‡•ç‡§õ',
          'thiyo',
          '‡§•‡§ø‡§Ø‡•ã',
          'garnu',
          'garne',
          'gareko',
          'garchan',
          'garchha',
          '‡§ó‡§∞‡•ç‡§õ',
          'bhayo',
          '‡§≠‡§Ø‡•ã',
          'bhanne',
          '‡§≠‡§®‡•ç‡§®‡•á',
          'ƒÅunu',
          'aunu',
          'jƒÅnu',
          'janu',
          'khƒÅnu',
          'khanu',
          'piunu',
          // Common words
          'ramro',
          '‡§∞‡§æ‡§Æ‡•ç‡§∞‡•ã',
          'sanchai',
          '‡§∏‡§û‡•ç‡§ö‡•à',
          'thik',
          '‡§†‡§ø‡§ï',
          'hajur',
          '‡§π‡•ã‡§á‡§®',
          'hoina',
          'haina',
          'ho',
          '‡§π‡•ã',
          'chaina',
          '‡§õ‡•à‡§®',
          'pardaina',
          '‡§™‡§∞‡•ç‡§¶‡•à‡§®',
          'sƒÅth',
          'sath',
          '‡§∏‡§æ‡§•',
          // Conversational
          'kasto chha',
          'kasto cha',
          'k cha',
          'k chha',
          'ramro chha',
          'thik chha',
          'thikka cha',
          'sanchai chu',
          'tapai lai',
          'malai lai',
          // Common phrases
          'bujhe',
          'bujhnu bhayo',
          'dekhna',
          'sunna',
          'bolna',
          'bolnu',
          'garna',
          '‡§™‡§®‡§ø',
          'pani',
          '‡§Æ‡§æ‡§§‡•ç‡§∞',
          'matra',
          '‡§Ö‡§≤‡§ø',
          'ali',
          'ekdam',
          '‡§è‡§ï‡§¶‡§Æ',
        ],
      },
      zh: {
        name: 'Chinese',
        flag: 'üá®üá≥',
        keywords: [
          // Common characters
          '‰Ω†Â•Ω',
          '‰Ω†',
          'Êàë',
          'ÊòØ',
          'ÁöÑ',
          '‰ªÄ‰πà',
          'ÊÄé‰πà',
          'Âì™Èáå',
          'Ë∞Å',
          '‰∏∫‰ªÄ‰πà',
          'ÂÅö',
          'Â∑•‰Ωú',
          'Âêó',
          'Âë¢',
          'Âú®',
          'Êúâ',
          'Ê≤°Êúâ',
          'ÂèØ‰ª•',
          'ËÉΩ',
          '‰ºö',
          'Ë¶Å',
          'ÊÉ≥',
          'ËØ¥',
          'ÂêÉ',
          'Âñù',
          'Âéª',
          'Êù•',
          'Ë∞¢Ë∞¢',
          'ÂØπ',
          '‰∏ç',
          // Romanized
          'ni hao',
          'ni',
          'wo',
          'shi',
          'de',
          'shenme',
          'zenme',
          'zuo',
          'gongzuo',
        ],
      },
      es: {
        name: 'Spanish',
        flag: 'üá™üá∏',
        keywords: [
          'hola',
          'que',
          'qu√©',
          'como',
          'c√≥mo',
          'estas',
          'est√°s',
          'donde',
          'd√≥nde',
          'cuando',
          'cu√°ndo',
          'por',
          'para',
          'tu',
          't√∫',
          'yo',
          'el',
          'la',
          'usted',
          'gracias',
          'por favor',
          'habla',
          'hablas',
          'eres',
          'soy',
          'bien',
          'mal',
          'trabajo',
          'hacer',
          'haces',
          'si',
          's√≠',
          'no',
          'bueno',
          'malo',
          'comer',
          'beber',
          'ir',
          'venir',
          'puedo',
          'puede',
          'quiero',
        ],
      },
      fr: {
        name: 'French',
        flag: 'üá´üá∑',
        keywords: [
          'bonjour',
          'salut',
          'comment',
          'quoi',
          'ou',
          'o√π',
          'qui',
          'pourquoi',
          'quand',
          'comment',
          'tu',
          'vous',
          'je',
          'moi',
          'le',
          'la',
          'merci',
          'parle',
          'parlez',
          'travail',
          'travailler',
          'faire',
          'fais',
          'faites',
          'oui',
          'non',
          'bien',
          'mal',
          "s'il vous pla√Æt",
          'sil vous plait',
          'manger',
          'boire',
          'aller',
          'venir',
          'peux',
          'peut',
          'veux',
          '√™tre',
          'suis',
          'es',
          'est',
        ],
      },
      tl: {
        name: 'Filipino/Tagalog',
        flag: 'üáµüá≠',
        keywords: [
          'kumusta',
          'ano',
          'paano',
          'saan',
          'sino',
          'bakit',
          'ikaw',
          'ako',
          'salamat',
          'trabaho',
          'gawa',
          'nag',
        ],
      },
      id: {
        name: 'Indonesian',
        flag: 'üáÆüá©',
        keywords: [
          'halo',
          'apa',
          'bagaimana',
          'dimana',
          'siapa',
          'mengapa',
          'kamu',
          'saya',
          'terima kasih',
          'kerja',
          'bekerja',
        ],
      },
      th: {
        name: 'Thai',
        flag: 'üáπüá≠',
        keywords: [
          // Thai script
          '‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ',
          '‡∏Ñ‡∏∏‡∏ì',
          '‡∏â‡∏±‡∏ô',
          '‡∏≠‡∏∞‡πÑ‡∏£',
          '‡∏ó‡∏µ‡πà‡πÑ‡∏´‡∏ô',
          '‡∏ó‡∏≥‡πÑ‡∏°',
          '‡∏ó‡∏≥‡∏á‡∏≤‡∏ô',
          '‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÑ‡∏£',
          '‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏´‡∏£‡πà',
          '‡πÉ‡∏Ñ‡∏£',
          '‡πÑ‡∏î‡πâ',
          '‡πÑ‡∏°‡πà',
          '‡∏°‡∏µ',
          '‡πÄ‡∏õ‡πá‡∏ô',
          '‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì',
          '‡∏Ñ‡∏£‡∏±‡∏ö',
          '‡∏Ñ‡πà‡∏∞',
          '‡∏î‡∏µ',
          '‡∏™‡∏ö‡∏≤‡∏¢‡∏î‡∏µ',
          '‡∏Å‡∏¥‡∏ô',
          '‡∏î‡∏∑‡πà‡∏°',
          // Romanized
          'sawasdee',
          'khun',
          'chan',
          'arai',
          'tee nai',
          'tam mai',
          'tamngan',
          'yangrai',
        ],
      },
      vi: {
        name: 'Vietnamese',
        flag: 'üáªüá≥',
        keywords: [
          'xin ch√†o',
          'ch√†o',
          'b·∫°n',
          't√¥i',
          'g√¨',
          '·ªü ƒë√¢u',
          'ƒë√¢u',
          't·∫°i sao',
          'sao',
          'l√†m',
          'vi·ªác',
          'l√†m vi·ªác',
          'c·∫£m ∆°n',
          'xin',
          'th·∫ø n√†o',
          'nh∆∞ th·∫ø n√†o',
          'khi n√†o',
          'ai',
          'c√≥',
          'kh√¥ng',
          'ƒë∆∞·ª£c',
          'l√†',
          'ƒÉn',
          'u·ªëng',
          'ƒëi',
          'ƒë·∫øn',
          't·ªët',
          'kh·ªèe',
          // Without tones (for text input)
          'chao',
          'ban',
          'toi',
          'cam on',
        ],
      },
      ar: {
        name: 'Arabic',
        flag: 'üá∏üá¶',
        keywords: [
          // Arabic script
          'ŸÖÿ±ÿ≠ÿ®ÿß',
          'ÿßŸÑÿ≥ŸÑÿßŸÖ',
          'ÿ£ŸÜÿ™',
          'ÿ£ŸÜÿß',
          'ŸÖÿßÿ∞ÿß',
          'ÿ£ŸäŸÜ',
          'ŸÑŸÖÿßÿ∞ÿß',
          'ŸÉŸäŸÅ',
          'ŸÖÿ™Ÿâ',
          'ŸÖŸÜ',
          'ÿπŸÖŸÑ',
          'ÿßŸÑÿπŸÖŸÑ',
          'ÿ¥ÿ∫ŸÑ',
          'ŸáŸÑ',
          'ŸÜÿπŸÖ',
          'ŸÑÿß',
          'ÿ¥ŸÉÿ±ÿß',
          'ÿ¥ŸÉÿ±ÿßŸã',
          'ÿ™ÿ¥ÿ±ŸÅŸÜÿß',
          'ÿ¨ŸäÿØ',
          'ÿ∑Ÿäÿ®',
          'ÿ™ŸÖÿßŸÖ',
          'ÿ£ŸÉŸÑ',
          'ÿ¥ÿ±ÿ®',
          // Romanized
          'marhaba',
          'salam',
          'anta',
          'ana',
          'madha',
          'ayna',
          'limadha',
          'kayf',
          'mata',
          'man',
        ],
      },
      ja: {
        name: 'Japanese',
        flag: 'üáØüáµ',
        keywords: [
          // Hiragana/Katakana
          '„Åì„Çì„Å´„Å°„ÅØ',
          '„Åä„ÅØ„Çà„ÅÜ',
          '„ÅÇ„Å™„Åü',
          'ÁßÅ',
          '‰Ωï',
          '„Å©„Åì',
          '„Å™„Åú',
          '„Å©„ÅÜ',
          '„Å©„ÅÜ„ÇÑ„Å£„Å¶',
          '„ÅÑ„Å§',
          '„Å†„Çå',
          'Ë™∞',
          '‰ªï‰∫ã',
          'ÂÉç„Åè',
          '„Åß„Åô',
          '„Åæ„Åô',
          '„ÅÇ„Çä„Åå„Å®„ÅÜ',
          '„ÅØ„ÅÑ',
          '„ÅÑ„ÅÑ„Åà',
          '„Çè„Åã„Çä„Åæ„Åó„Åü',
          'È£ü„Åπ„Çã',
          'È£≤„ÇÄ',
          'Ë°å„Åè',
          'Êù•„Çã',
          '„Çà„ÅÑ',
          '„ÅÑ„ÅÑ',
          // Romanized
          'konnichiwa',
          'ohayo',
          'anata',
          'watashi',
          'nani',
          'doko',
          'naze',
          'dou',
          'itsu',
          'dare',
        ],
      },
      ko: {
        name: 'Korean',
        flag: 'üá∞üá∑',
        keywords: [
          // Hangul
          'ÏïàÎÖïÌïòÏÑ∏Ïöî',
          'ÏïàÎÖï',
          'ÎãπÏã†',
          'ÎÇò',
          'Ï†Ä',
          'Î¨¥Ïóá',
          'Î≠ê',
          'Ïñ¥Îîî',
          'Ïôú',
          'Ïñ¥ÎñªÍ≤å',
          'Ïñ∏Ï†ú',
          'ÎàÑÍµ¨',
          'Ïùº',
          'ÏùºÌïòÎã§',
          'ÌïòÎã§',
          'ÏûàÎã§',
          'ÏóÜÎã§',
          'Í∞êÏÇ¨Ìï©ÎãàÎã§',
          'Í≥†ÎßôÏäµÎãàÎã§',
          'ÎÑ§',
          'ÏïÑÎãàÏöî',
          'Ï¢ãÏïÑÏöî',
          'Ï¢ãÎã§',
          'Î®πÎã§',
          'ÎßàÏãúÎã§',
          'Í∞ÄÎã§',
          'Ïò§Îã§',
          // Romanized
          'annyeong',
          'annyeonghaseyo',
          'dangsin',
          'na',
          'jeo',
          'mueot',
          'mwo',
          'eodi',
          'wae',
          'eotteoke',
          'eonje',
          'nugu',
        ],
      },
      pt: {
        name: 'Portuguese',
        flag: 'üáßüá∑',
        keywords: [
          'ola',
          'ol√°',
          'oi',
          'como',
          'que',
          'qu√™',
          'onde',
          'quando',
          'por',
          'porqu√™',
          'porque',
          'tu',
          'voce',
          'voc√™',
          'eu',
          'obrigado',
          'obrigada',
          'fala',
          'falar',
          'trabalho',
          'trabalhar',
          'fazer',
          'faz',
          'sim',
          'n√£o',
          'nao',
          'bem',
          'mal',
          'bom',
          'ruim',
          'comer',
          'beber',
          'ir',
          'vir',
          'posso',
          'pode',
          'quero',
          'est√°',
          'esta',
          'ser',
        ],
      },
      ru: {
        name: 'Russian',
        flag: 'üá∑üá∫',
        keywords: [
          // Cyrillic
          '–ø—Ä–∏–≤–µ—Ç',
          '–∑–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ',
          '—Ç—ã',
          '–≤—ã',
          '—è',
          '—á—Ç–æ',
          '–≥–¥–µ',
          '–ø–æ—á–µ–º—É',
          '–∫–∞–∫',
          '–∫–æ–≥–¥–∞',
          '–∫—Ç–æ',
          '—Ä–∞–±–æ—Ç–∞',
          '—Ä–∞–±–æ—Ç–∞—Ç—å',
          '–¥–µ–ª–∞—Ç—å',
          '–¥–∞',
          '–Ω–µ—Ç',
          '—Å–ø–∞—Å–∏–±–æ',
          '—Ö–æ—Ä–æ—à–æ',
          '–ø–ª–æ—Ö–æ',
          '–µ—Å—Ç—å',
          '–ø–∏—Ç—å',
          '–∏–¥—Ç–∏',
          '–±—ã—Ç—å',
          '–º–æ–∂–Ω–æ',
          '–Ω—É–∂–Ω–æ',
          // Romanized
          'privet',
          'zdravstvuyte',
          'ty',
          'vy',
          'ya',
          'chto',
          'gde',
          'pochemu',
          'kak',
          'kogda',
          'kto',
        ],
      },
      de: {
        name: 'German',
        flag: 'üá©üá™',
        keywords: [
          'hallo',
          'guten tag',
          'wie',
          'was',
          'wo',
          'wer',
          'warum',
          'wann',
          'du',
          'sie',
          'ich',
          'danke',
          'bitte',
          'arbeit',
          'arbeiten',
          'machen',
          'machst',
          'ja',
          'nein',
          'gut',
          'schlecht',
          'essen',
          'trinken',
          'gehen',
          'kommen',
          'kann',
          'm√∂chte',
          'sein',
          'bin',
          'bist',
          'ist',
          'sprechen',
          'sprichst',
        ],
      },
      it: {
        name: 'Italian',
        flag: 'üáÆüáπ',
        keywords: [
          'ciao',
          'come',
          'cosa',
          'dove',
          'chi',
          'perche',
          'tu',
          'io',
          'grazie',
          'parla',
          'parli',
        ],
      },
    }

    // Check each language for keyword matches
    let bestMatch = { lang: 'en', count: 0, name: 'English', flag: 'üá¨üáß' }

    // If Deepgram detected a non-English language, use it as a strong hint
    if (deepgramHint && deepgramHint !== 'en' && deepgramHint !== 'unknown') {
      // Map Deepgram language codes to our codes
      const deepgramLangMap: Record<string, string> = {
        es: 'es',
        'es-419': 'es',
        'es-ES': 'es',
        zh: 'zh',
        'zh-CN': 'zh',
        'zh-TW': 'zh',
        hi: 'hi',
        'hi-IN': 'hi',
        ne: 'ne',
        'ne-NP': 'ne',
        fr: 'fr',
        'fr-FR': 'fr',
        fil: 'fil',
        'fil-PH': 'fil',
        id: 'id',
        'id-ID': 'id',
        th: 'th',
        'th-TH': 'th',
        vi: 'vi',
        'vi-VN': 'vi',
        ar: 'ar',
        'ar-SA': 'ar',
        ja: 'ja',
        'ja-JP': 'ja',
        ko: 'ko',
        'ko-KR': 'ko',
        pt: 'pt',
        'pt-BR': 'pt',
        'pt-PT': 'pt',
        ru: 'ru',
        'ru-RU': 'ru',
        de: 'de',
        'de-DE': 'de',
        it: 'it',
        'it-IT': 'it',
      }

      const mappedLang = deepgramLangMap[deepgramHint] || deepgramHint

      // SPECIAL CASE: If Deepgram says Hindi, check if it's actually Nepali
      // (Deepgram doesn't support Nepali, so it transcribes as Hindi)
      if (mappedLang === 'hi' || deepgramHint === 'hi-IN') {
        console.log("üîç Deepgram detected Hindi, checking if it's actually Nepali...")

        // Check for Nepali-specific keywords
        const nepaliKeywords = languagePatterns.ne.keywords
        const nepaliMatches = nepaliKeywords.filter((keyword) => {
          const keywordLower = keyword.toLowerCase()
          if (keywordLower.includes(' ')) {
            return messageLower.includes(keywordLower)
          }
          const wordBoundaryRegex = new RegExp(`\\b${keywordLower}\\b`, 'i')
          return wordBoundaryRegex.test(message)
        }).length

        // Check for Hindi-specific keywords
        const hindiKeywords = languagePatterns.hi.keywords
        const hindiMatches = hindiKeywords.filter((keyword) => {
          const keywordLower = keyword.toLowerCase()
          if (keywordLower.includes(' ')) {
            return messageLower.includes(keywordLower)
          }
          const wordBoundaryRegex = new RegExp(`\\b${keywordLower}\\b`, 'i')
          return wordBoundaryRegex.test(message)
        }).length

        console.log(`  üìä Nepali keywords: ${nepaliMatches}, Hindi keywords: ${hindiMatches}`)

        // If more Nepali keywords than Hindi, it's Nepali!
        if (nepaliMatches > hindiMatches && nepaliMatches >= 1) {
          console.log('üá≥üáµ Actually Nepali! (Deepgram transcribed as Hindi)')
          return {
            detectedLanguage: 'ne',
            confidence: 0.95,
            translatedQuery: message,
            culturalContext: ['friendly'],
            preferredResponseLanguage: 'ne',
            needsTranslation: false,
          }
        }
      }

      const langData = languagePatterns[mappedLang as keyof typeof languagePatterns]

      if (langData) {
        // VERIFICATION: Double-check Deepgram's detection against text patterns
        // This prevents misdetections like Spanish being detected as Russian
        console.log(`üîç Verifying Deepgram's ${deepgramHint} detection against text patterns...`)

        // Count keyword matches for Deepgram's detected language
        const deepgramMatches = langData.keywords.filter((keyword) => {
          const keywordLower = keyword.toLowerCase()
          // For multi-word keywords, use simple substring match
          if (keywordLower.includes(' ')) {
            return messageLower.includes(keywordLower)
          }
          // For single words, use word boundary regex
          const wordBoundaryRegex = new RegExp(`\\b${keywordLower}\\b`, 'i')
          return wordBoundaryRegex.test(message)
        }).length

        // Check if ANY other language has MORE matches
        let strongerMatch = null
        for (const [langCode, otherLangData] of Object.entries(languagePatterns)) {
          if (langCode === mappedLang) continue // Skip Deepgram's language

          const otherMatches = otherLangData.keywords.filter((keyword) => {
            const keywordLower = keyword.toLowerCase()
            // For multi-word keywords, use simple substring match
            if (keywordLower.includes(' ')) {
              return messageLower.includes(keywordLower)
            }
            // For single words, use word boundary regex
            const wordBoundaryRegex = new RegExp(`\\b${keywordLower}\\b`, 'i')
            return wordBoundaryRegex.test(message)
          }).length

          // If another language has significantly more matches, it's likely the correct one
          if (otherMatches > deepgramMatches && otherMatches >= 2) {
            strongerMatch = { lang: langCode, data: otherLangData, matches: otherMatches }
            break
          }
        }

        if (strongerMatch) {
          console.log(
            `‚ö†Ô∏è Text patterns suggest ${strongerMatch.data.flag} ${strongerMatch.data.name} (${strongerMatch.matches} matches) instead of ${langData.flag} ${langData.name} (${deepgramMatches} matches)`,
          )
          console.log(`üîÑ Overriding Deepgram's detection: ${deepgramHint} ‚Üí ${strongerMatch.lang}`)
          return {
            detectedLanguage: strongerMatch.lang,
            confidence: 0.9, // High confidence from text pattern override
            translatedQuery: message,
            culturalContext: ['friendly'],
            preferredResponseLanguage: strongerMatch.lang,
            needsTranslation: false,
          }
        }

        console.log(
          `‚úÖ Deepgram detection verified: ${langData.flag} ${langData.name} (${deepgramMatches} text matches)`,
        )
        return {
          detectedLanguage: mappedLang,
          confidence: 0.98, // High confidence from Deepgram
          translatedQuery: message,
          culturalContext: ['friendly'],
          preferredResponseLanguage: mappedLang,
          needsTranslation: false,
        }
      }
    }

    for (const [langCode, langData] of Object.entries(languagePatterns)) {
      const matches = langData.keywords.filter((keyword) => {
        // Use whole-word matching to avoid false positives (e.g., "me" in "tell me", "el" in "tell")
        const keywordLower = keyword.toLowerCase()
        // For multi-word keywords (like "por favor"), use simple substring match
        if (keywordLower.includes(' ')) {
          return messageLower.includes(keywordLower)
        }
        // For single words, use word boundary regex to match whole words only
        const wordBoundaryRegex = new RegExp(`\\b${keywordLower}\\b`, 'i')
        return wordBoundaryRegex.test(message)
      }).length

      if (matches > bestMatch.count) {
        bestMatch = { lang: langCode, count: matches, name: langData.name, flag: langData.flag }
      }
    }

    // Require at least 2 matches for short messages (< 10 words), 1 match for longer messages
    const wordCount = message.split(/\s+/).length
    const requiredMatches = wordCount >= 10 ? 1 : 2

    if (bestMatch.count >= requiredMatches) {
      console.log(
        `${bestMatch.flag} ${bestMatch.name} detected: ${bestMatch.count} keywords matched (required: ${requiredMatches})`,
      )
      return {
        detectedLanguage: bestMatch.lang,
        confidence: 0.95,
        translatedQuery: message,
        culturalContext: ['friendly'],
        preferredResponseLanguage: bestMatch.lang,
        needsTranslation: false,
      }
    }

    // Default to English if no language detected
    console.log(`üá¨üáß English detected (default) - no Hindi/Nepali patterns found`)
    return {
      detectedLanguage: 'en',
      confidence: 0.8,
      culturalContext: ['professional'],
      preferredResponseLanguage: 'en',
      needsTranslation: false,
    }
  } catch (error) {
    console.error('Language detection failed:', error)
    return {
      detectedLanguage: 'en',
      confidence: 0.8,
      culturalContext: ['professional'],
      preferredResponseLanguage: 'en',
      needsTranslation: false,
    }
  }
}

/**
 * Multi-Language Response Generation
 */
export async function generateMultiLanguageResponse(
  ragResult: any,
  languageContext: LanguageContext,
  originalMessage: string,
  sessionId: string = 'default-session',
  conversationHistory: any[] = [],
): Promise<MultiLanguageRAGResult> {
  try {
    // Check for pre-built templates first for common phrases
    if (languageContext.detectedLanguage !== 'en') {
      const template = findConversationTemplate(originalMessage)
      if (template) {
        const templateResponse = getTemplateResponse(template, languageContext.detectedLanguage)
        if (templateResponse) {
          console.log('‚úÖ Using natural language template')
          return {
            response: templateResponse,
            originalLanguage: languageContext.detectedLanguage,
            responseLanguage: languageContext.detectedLanguage,
            translationUsed: false,
            searchLanguage: languageContext.detectedLanguage,
            metadata: {
              languageDetection: languageContext,
              ragPattern: 'template_response',
              searchResults: 0,
              crossLanguageSearch: false,
              templateUsed: template.context,
            },
          }
        }
      }
    }

    // Generate contextual response
    let finalResponse = ragResult.response
    let translationUsed = false

    if (languageContext.detectedLanguage !== 'en' && languageContext.confidence > 0.7) {
      console.log(`üåç Generating ${languageContext.detectedLanguage} response`)

      const languageNames: Record<string, string> = {
        hi: 'Hindi/Hinglish',
        ne: 'Nepali',
        zh: 'Chinese (Mandarin)',
        es: 'Spanish',
        fr: 'French',
        tl: 'Filipino/Tagalog',
        id: 'Indonesian',
        th: 'Thai',
        vi: 'Vietnamese',
        ar: 'Arabic',
        ja: 'Japanese',
        ko: 'Korean',
        pt: 'Portuguese',
        ru: 'Russian',
        de: 'German',
        it: 'Italian',
      }

      const langName =
        languageNames[languageContext.detectedLanguage] || languageContext.detectedLanguage

      const responsePrompt = `You are Sajal Basnet (software developer with Masters from Swinburne University, Sydney) responding to someone in ${langName}.

User asked: "${originalMessage}"
Context: ${ragResult.response.substring(0, 200)}

Reply in natural ${langName}:
- Keep it conversational and friendly (1-2 sentences max)
- Use natural grammar and common phrases
- Be professional but warm
- Answer the question directly

Response:`

      try {
        // AGGRESSIVE TIMEOUT for translation (2s max!)
        const translationPromise = groq.chat.completions.create({
          model: 'llama-3.1-8b-instant', // Fast model
          messages: [{ role: 'user', content: responsePrompt }],
          max_tokens: 100, // Reduced from 150 for speed
          temperature: 0.5, // Lower for faster generation
        })

        const response = await Promise.race([
          translationPromise,
          new Promise<any>((_, reject) =>
            setTimeout(() => reject(new Error('Groq translation timeout 2s')), 2000),
          ),
        ])

        const generatedText = response.choices[0].message.content
        if (generatedText) {
          finalResponse = cleanQuotes(generatedText.trim())
          translationUsed = true
          console.log(`‚úÖ ${langName} translation completed`)
        }
      } catch (error) {
        console.error(`‚ö†Ô∏è ${langName} translation timeout/failed, using English:`, error)
        // Fallback to English if translation fails or times out
      }
    }

    return {
      response: finalResponse,
      originalLanguage: languageContext.detectedLanguage,
      responseLanguage: languageContext.detectedLanguage,
      translationUsed,
      searchLanguage: languageContext.detectedLanguage,
      metadata: {
        languageDetection: languageContext,
        ragPattern: ragResult.metadata?.ragPattern || 'unknown',
        searchResults: ragResult.metadata?.resultsFound || 0,
        crossLanguageSearch: languageContext.needsTranslation || false,
      },
    }
  } catch (error) {
    console.error('Multi-language response generation failed:', error)
    return {
      response: ragResult.response,
      originalLanguage: 'en',
      responseLanguage: 'en',
      translationUsed: false,
      searchLanguage: 'en',
      metadata: {
        languageDetection: languageContext,
        ragPattern: ragResult.metadata?.ragPattern || 'unknown',
        searchResults: ragResult.metadata?.resultsFound || 0,
        crossLanguageSearch: false,
      },
    }
  }
}

/**
 * Enhanced Query Processing for Multi-Language Support
 */
export async function processMultiLanguageQuery(
  message: string,
  contextEnhanced: any,
  sessionId: string,
): Promise<{
  languageContext: LanguageContext
  selectedPattern: {
    pattern:
      | 'advanced_agentic'
      | 'multi_hop'
      | 'hybrid_search'
      | 'tool_enhanced'
      | 'standard_agentic'
    searchQuery: string
    reasoning: string
  }
  enhancedQuery: string
}> {
  // Step 1: Detect language and context
  const languageContext = await detectLanguageContext(message)
  console.log(
    `üåç Language detected: ${languageContext.detectedLanguage} (confidence: ${languageContext.confidence})`,
  )

  // Step 2: Select appropriate RAG pattern
  const selectedPattern = {
    pattern: 'standard_agentic' as const,
    searchQuery: message,
    reasoning: `Standard agentic RAG for ${languageContext.detectedLanguage} query`,
  }

  // Step 3: Enhance query for better search
  const enhancedQuery = languageContext.needsTranslation ? selectedPattern.searchQuery : message

  return {
    languageContext,
    selectedPattern,
    enhancedQuery,
  }
}

/**
 * Smart Filtering for Multi-Language Results
 */
export async function applySmartFiltering(
  results: VectorResult[],
  languageContext: LanguageContext,
  originalQuery: string,
): Promise<VectorResult[]> {
  if (results.length === 0) return results

  try {
    // For now, just return the top results
    // Can be enhanced with actual filtering logic later
    return results.slice(0, 5)
  } catch (error) {
    console.error('Smart filtering failed:', error)
    return results.slice(0, 5)
  }
}

/**
 * Clean up quotation marks and extra formatting
 */
function cleanQuotes(text: string): string {
  return text
    .replace(/^["'"\u201C\u201D\u2018\u2019]+|["'"\u201C\u201D\u2018\u2019]+$/g, '')
    .replace(/^"(.+)"$/s, '$1')
    .replace(/^'(.+)'$/s, '$1')
    .trim()
}
